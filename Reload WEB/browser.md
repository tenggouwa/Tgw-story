重学前端10， 浏览器如何工作的
===
+ 浏览器工作步骤

      1.浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；
      2.把请求回来的 HTML 代码经过解析，构建成 DOM 树；
      3.计算 DOM 树上的 CSS 属性；
      4.最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；
      5.一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；
      6.合成之后，再绘制到界面上。
    
+ http协议

      请求头，请求体，响应头，响应体
      http方法
      GET POST
      HEAD与GET类似，但是只返回请求头
      PUT DELETE 表示添加资源与删除资源
      CONNECT https和ws的请求
      OPTIONS TRACE 用于调试，多数不支持

+ 状态码

      1xx: 临时回应，客户端继续
      2xx: 请求成功
      3xx: 请求的目标用变化 304客户端缓存没更新
      4xx: 请求错误 403没权限 404不存在 
      5xx: 服务端请求错误

****
重学前端11，如何解析HTML DOM如何构建
===

+ 词(token)是如何被划分的

      <p class="a">text text text</p>
      1.<p“标签开始”的开始；
      2.class=“a” 属性；
      3.>  “标签开始”的结束；
      4.text text text 文本；
      5.</p> 标签结束。 

    示例词(token) | 解释
    :-: | :-:
    <abc | 开始标签的开始 |
    a="xxx" | 属性 |
    /> | 开始标签的结束 |
    </xxx> | 结束标签 |
    hello world | 文本节点 |
    < !-- xx --> | 注释 |

****
重学前端12，如何在DOM树上添加CSS
===

+ 整体认知

      css不是构件号DOM后再选择的，而是同步的在创建DOM时就添加上的
      
      部分选择器

      1.空格: 后代，选中它的子节点和所有子节点的后代节点。
      2.>: 子代，选中它的子节点。
      3.+：直接后继选择器，选中它的下一个相邻节点。
      4.~：后继，选中它之后所有的相邻节点。
      5.||：列，选中表格中的一列。

**** 
重学前端13， 排版
====

+ 正常流  包括绝对定位元素以及浮动元素

+ 正常流文字排版

      注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。

+ 正常流中的盒 
  + 行内盒

        与文字一起排版
  + 块级盒

        块级盒比较简单，它总是单独占据一整行

+ 绝对定位元素

      position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。

+ 浮动元素排版

      float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。
      移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。

+ 其它的排版

      CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。

**** 
重学前端14， 渲染
====
+ 总体

      浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。

+ 合成
  + 合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。

+ 绘制
   + 一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。